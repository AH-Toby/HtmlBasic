# JavaScript基础(四)

## 一.函数

**作用：** 函数就是功能。我们可以自己封装一些语句在函数内部，函数就具有了某一种特定的功能。

### 1.1.函数的声明

**语法：** function后面紧跟空格，空格后面书写函数名，函数名跟着小括号(参数)。小括号后面书写结构体，用大括号包裹。

**结构：**

```js
function 函数名称 (参数集合--形参) {
    结构体;
}
```

> 注：
>
> 函数名必须遵守标识符的定义规则，则必须是数字、大小写字母、$、_组成且不能以数字开头

通过函数声明来定义的一个函数方式也叫**函数定义式。**

函数内部可以封装一段语句，这些语句是一个整体，调整的时候，这些语句要全部一起执行。

大括号中书写我们想要执行的语句(函数体，结构体)

函数声明只是告诉我们函数里面有哪些语句。并不会执行。

函数的优点：可以把一些重复性的语句封装在函数内部，多次调用。简化代码书写。

[函数示例](../code/20.JavaScript基础(四)/1.函数.html)

### 1.2.函数的调用

**语法：** 函数名紧跟小括号

**结构：**

```js
函数名()
```

> 注：
>
> 1.函数只有先声明，才能够调用。
>
> 2.函数声明，只是告诉我们函数执行时有哪些语句，这里的语句并不会自己去执行。
>
> 3.函数想要执行，必须去调用。
>
> 4.函数的执行和声明位置没有关系，和函数的调用有关

[函数的调用示例](../code/20.JavaScript基础(四)/2.函数的调用.html)

### 1.3.函数的参数

函数声明：

```js
function 函数名称 (参数集合--形参) {
    结构体;
}
```

> 注意：
>
> 形参也是变量，命名规则与变量一样

调用函数：

```js
函数名(传递参数);
```

形参和实参的个数可以不相同：

1.如果实参个数多于形参个数。形参集合将多余的部分直接舍弃

2.如果实参个数少于形参个数。优先将实参赋值给前面的变量

**arguments:** arguments是函数自带的属性，是由实参组成的类数组对象

js是一个动态类型数据语言，变量的数据类型根据里面存放的内容变化二变化。

实参的数据类型回影响形参的数据类型。

实参可以传任何类型的值

函数的优点：函数有参数，相当于给我提供一个API接口，我们可以通过接口去调用函数，执行不同的操作，后面封装函数的时候，只需要了解API的用途就够了，就是传参之后有什么结果，不用去了解函数的构造。不论是自己的函数还是用的别人封装好的函数，都只需要知道怎么用就够了。

[函数的参数示例](../code/20.JavaScript基础(四)/3.函数的参数.html)

### 1.4.return

函数可以用变量来接收参数，还可以用return关键词返回数据

函数执行完毕有两种情况：

一种是没有结果（默认），一种是由结果（通过return返回）

**作用：** 返回数据

**结构**：

```js
function 函数名称 (参数集合--形参) {
    结构体;
    return 要返回的数据;
}
```

> 注意：
>
> 1.return不会输出，想看输出结果需要使用输出语句
>
> 2.返回值将我们的函数矮化成一个表达式。利用这个特性，我们可以将函数作为一个实际参数，传递给另外一个函数。
>
> 3.函数内部遇见return，会立即返回，也就是结束函数执行，return后面的其他语句不执行

函数的优点：我们可以将一个函数的返回值，传递给另外一个函数，有利于我们的模块化编程。

[return关键字示例](../code/20.JavaScript基础(四)/4.return关键字.html)

### 1.5.模块化编程

含义：将一些基础的公共的部分单独封装到一个函数内，可以被多次调用

注意：模块化编程，可以让我们的程序更加优化，各个小模块要尽量功能单一

[模块化编程示例](../code/20.JavaScript基础(四)/5.模块化编程.html)

[完美数示例](../code/20.JavaScript基础(四)/6.完美数.html)

### 1.6.函数表达式

函数声明可以使用关键词function，还可以使用函数表达式。

就是将一个匿名函数赋值给一个变量。匿名函数后面的小括号也是书写参数

匿名函数也叫拉姆达函数

**结构：**

```js
// 定义
var 变量 = function(参数集合){结构体};
// 调用
变量();
```

> 注意：
>
> 函数定义式的函数后面不需要加分号，而函数表达式形式定的函数，后面必须加分号
>
> 函数的调用和之前一样，函数名();

[函数表达式示例](../code/20.JavaScript基础(四)/7.函数表达式.html)

### 1.7.函数的数据类型

函数不管是函数表达式还是函数定义式，通过typeof查看都是function

**简单数据类型(值类型数据)：**

变量可以进行赋值，变量也可以接受任何数据类型。不同变量之间进行赋值运算时，只是将变量的值进行赋值然后再赋值给另一个变量。当一个变量的值改变时，其他的变量不受影响。

**引用数据类型：**

再进行赋值时，将变量的地址，赋值给另外一个变量（两个变量同时指向同一数据）。当一个变量该表时，另外一个也会受到影响

函数就是一个引用类型的数据

**总结：** 简单数据类型赋值是值，引用数据类型赋值时地址。

[函数的数据类型示例](../code/20.JavaScript基础(四)/8.函数的数据类型.html)

### 1.8.函数声明提升

**变量声明提升：**

变量可以先使用，后声明再计算机预解析时，会将所有变量声明提升到语句最前面。使用不会报错，但是只提升变量声明，不提升变量的赋值。输出undefined

**函数声明的提升：**

函数也可以先使用，后声明。因为在计算机预解析时，同样也是先将函数的声明提升到语句最前面，并且是将函数的定义全部提升到最前面。

> 注意:
>
> 函数定义式会提升整个函数，函数表达式只会提升变量的声明。
>
> 所以在实际工作中一般使用function关键词定义函数，而不是使用函数表达式，以防出错，或者先定义后使用。
>
> 我们习惯先调用函数，将函数的申明放在最后。是代码清晰可读。

**JavaScript运行分为词法分析和执行两个阶段：**

词法分析主要分为3步：

第一步：分析形参

第二部：变量声明

第三步：分析函数声明

> 注意：
>
> 如果存在函数嵌套，则从外往内进行词法分析

[函数声明提升示例](../code/20.JavaScript基础(四)/9.函数声明提升.html)

### 1.9.声明提升原理

**具体步骤：**

在函数执行的一瞬间，生产Active Object（活动对象|容器），下面简称AO

函数声明的形参，形成AO的属性(放在容器中)，默认是undefined：

​	接收实参，给刚刚形成AO的属性的形参赋值

分析var声明变量，如var a;(变量的值是在运行时期决定)：

​	如果AO上还没有a属性，则给AO添加a属性，默认值是undefined。

​	如果AO上已经有a属性，则不做任何操作

分析函数声明：如function demo(){}

​	如果AO上没有demo属性，则把函数赋给AO.demo属性

​	如果AO上有demo属性，则会直接覆盖，把函数赋值给AO.demo属性

执行函数时，如果声明的变量有赋值，则为变量赋值。

工作中，为了避免这些问题，不要让变量，形参，函数同名

[函数声明提升原理示例](../code/20.JavaScript基础(四)/10.函数声明提升原理.html)

### 2.0.局部变量和全局变量

**局部变量：**

在一个作用域(定义域)内定义的变量就是这个作用域内的局部变量。只能在作用域内被访问到。

**全局变量：**

从广义上来看，全局变量也是一种局部变量。全局变量定义在全局，所以才叫全局变量。可以在任何地方都被访问到

**变量声明的原理：**

全局变量，在全局定义后，会永久存在，任何时候，任何位置访问，都能够找到他。局部变量定义在函数内部，函数定义的过程，并没有真正地去定义这个局部变量，只有在执行函数的时候，才会立即定义这个局部变量，执行完之后，变量就会被立即销毁，在其他地方访问变量的时候，找不到这个变量所以才会有一个引用错误，变量未定义

形参的作用域就是这个变量所在的函数。在这个函数外任何地方都不能得到这个形参。

[局部变量和全局变量示例](../code/20.JavaScript基础(四)/11.局部变量和全局变量.html)

### 2.1.全局变量的应用

**传递作用：**

全局变量可以在不同函数内，进行传递作用。

不管哪个函数都可以控制这个全局变量。全局变量不会重置也不会清空

**通信作用：**

全局变量还可以在相同函数中，进行通信作用

声明一次函数，可以多次调用。全局变量不会被重置,也不会被清空。而是记住当前的值来参与运算。

[全局变量的作用示例](../code/20.JavaScript基础(四)/12.全局变量的作用.html)

## 二、递归函数

**作用：** 递归函数一般用于解决数学问题。

**含义：** 在函数内部调用自身。通常会设置一个临界条件，当达到临界条件，停止递归调用。

**递归过程：** 首先递归函数会一层一层进入函数，直到遇见临界点，然后从临界点一层一层向外计算结果。

**结构：**

```js
function 函数名(参数) {
    函数名(参数);
}
```

[递归函数示例](../code/20.JavaScript基础(四)/13.递归函数.html)

案例：斐波那契数列：1，1，2，3，5，8，12，21，34

[斐波那契数列示例](../code/20.JavaScript基础(四)/14.斐波那契数列.html)

## 三、作用域链

**变量的作用域：**

在函数中声明的变量，只能在函数内部使用，在函数外部的任何地方都不能访问的到这个变量。目前来说，在js中只有函数能关住变量，所以js中变量名的作用域时函数级别的。

**作用域链：**

是指变量查找的规律：我们可以在不同的作用域内使用相同的标识符去命名变量。在使用一个变量的时候，需要找到匹配的表示符，有重复的标识符，该用哪一个？如果在当前作用域有这个变量，就可以直接使用，如果当前作用域没有这个变量，会一层一层的从本层向外层一次查找，直到遇到第一个该标识符。类似于就近原则。

当遇到一个变量时，JS引擎会从其所在作用域依次向外层查询，查找会在找到第一个匹配的标识符时候停止。在多层嵌套的作用域中可以定义同名的标识符，发生遮蔽效应。

如果变量声明时，不写var关键字，计算机会自动在全局作用域内给它进行依次声明，局部变量就强制性的编程了全局变量。这种情况时不合理的，会造成全局变量污染，所以，定义变量必须写var关键字。

**函数的作用域(定义时确定)：** 函数的作用域和变量相似，也是在声明函数的地方调用，在外部任何地方都不能使用，不受函数执行影响。

[作用域示例](../code/20.JavaScript基础(四)/15.作用域.html)

## 四、闭包

**定义：**

闭包是指有权访问另一个函数作用域中的变量的函数

内部函数把它自己内部的语句，和它声明时所处的作用域一起封装成一个密闭的环境，我们称之为闭包。

**结构：**

```js
// 定义
function 函数名(参数) {
    return function(参数){
        return 数据;
    }
}

// 调用
var 变量名 = 函数名(参数);
变量名(参数);
```

函数定义的时候，就能记住它的外部环境和内部语句，每次执行都会参考定义式的密闭环境。

闭包天生存在，不需要什么特殊的结构才存在，我们必须要刻意的把函数放到其他的作用域中，才能明显地观察到闭包性质。

闭包能够记住外部环境和内部语句。但是外部环境并不是一成不变的。每一次函数的调用都会产生一个全新的闭包。函数的密闭，内部语句和外部环境都是全新。

**作用：**

**外部函数可以起到封闭空间存储的作用，供闭包使用**

>  注意：
>
> 闭包无法被js垃圾回收机制自动回收
>
> 闭包函数本身也具有一个作用域,因此于外界产生命名冲突的时候,根据作用域链的原则,会优先使用内部的数据

[闭包示例](../code/20.JavaScript基础(四)/16.闭包.html)

## 五、IIFE函数

IIFE是一个缩写，immediately-invoked function expression。即时调用函数表达式。

IIFE表示在函数定义的时候，就立即执行。

在函数后面直接添加小括号。小括号表示函数调用。小括号只能用在函数名或者函数表达式后面。

**结构:**

```js
// 函数定义式
var 返回值 = (function 函数名(行参){return 数据})(形参);
// 函数表达式
var 返回值 = function (行参){return 数据}(形参);
```

函数定义式：需要将函数矮化为函数表达式。可以使用数学运算符，如+，-，！（）。

一般我们使用小括号将函数包裹矮化为函数表达式。并一般我们直接使用匿名函数。

> 注意：
>
> 转化成表达式之后，在后面要添加";"，否则表达式运行在一起会报错
>
> 函数定义式定义的函数，此时函数以及转为表达式了，不能提升，不能访问
>
> 函数表达式定义的IIFE，此时存储的是函数运行结果。 

**IIFE函数特点：**

**IIFE能管住函数的作用域。**在IIFE外部任何地方都不能访问到。

**IIFE实际参数书写在立即调用小括号中。**

**IIFE本身相当于表达式**。如果内部有return关键字，IIFE可以作为数值参与其他运算(函数)。


[IIFE函数示例](../code/20.JavaScript基础(四)/17.IIFE函数.html)



